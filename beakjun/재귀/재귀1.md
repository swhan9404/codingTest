# 11729 하노이탑

https://www.acmicpc.net/problem/11729

```python
나의 풀이

import sys

inp = int(sys.stdin.readline().rstrip())

print(2**inp -1)

def func(n, start, end, extra) :
  if n ==1 :
    print(start, end)
  else :
    func(n-1, start, extra, end)
    func(1, start, end, extra)
    func(n-1, extra, end, start)

func(inp, 1, 3, 2)
```

```python
나보다 빠르고 간결해 보이는 풀이
def m(n,a,b,c):
    y=a+' '+c
    if n==1:
        return y
    x=m(n-1,a,c,b)
    z=m(n-1,b,a,c)
    return '\n'.join([x,y,z])

s=m(int(input()),'1','2','3')
print(s.count('\n')+1)
print(s)

```

- 푸는 방식
  1. 가장 큰 n 번째 원판을 제외한 n-1개의 원판을 기둥 A,B가 아닌 다른 중간 기둥으로 옮긴다
  2. n번째 원판을 기둥 A에서 기둥 B로 옮긴다.
  3. n-1개의 원판을 중간기둥에서 기둥 B로 옮긴다.
- 최소 수행 횟수

$$
n개를 옮기는데 필요한 최소의 시행 횟수 : h(n) \\
h(1) = 1 \\
h(n) = 2h(n-1) + 1 (n>=2) \\
여기서 양변에 1을 더해서 유도 \\
h(n) + 1 = 2(h(n-1) + 1) \\
h(n) = 2^n -1
$$

# 6603 경우의 수 전부 구하기

https://www.acmicpc.net/problem/6603

<나의 풀이>

```python
# 재귀함수
def func(x, cnt): # 어디까지 갔는지, 얼마나 뽑았는지
  # cnt == 6 일때
  if cnt == 6:
    for i in range(k):
      if select[i]:
        print(S[i], end=' ')
    print()
    return
  # 아닐 때
  for i in range(x, k):
    select[i] = True
    func(i+1, cnt+1)
    select[i] = False

# while 문 입력 루프
while True:
  # 입력하기 K, S 분류
  inp = list((map(int, input().split())))
  k = inp[0]
  S = inp[1:]
  # k ==0 일때 탈출
  if k == 0:
    break
  # 뽑은거 리스트
  select = [False for _ in range(k)]
  func(0, 0)
  print()
```

< 다른 풀이 - itertools.combinations 이용>

``` python
from itertools import combinations

while True:
    s = list(map(int, input().split()))
    if s[0] == 0:
        break
    del s[0]
    s = list(combinations(s, 6))
    for i in s:
        for j in i:
            print(j, end=' ')
        print()
    print()
```

